<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Content/_index.md on Wally Trace</title>
    <link>http://localhost:1313/</link>
    <description>Recent content in Content/_index.md on Wally Trace</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <copyright>© 2025 </copyright>
    <lastBuildDate>Wed, 31 Dec 2025 14:57:30 -0500</lastBuildDate><atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Review 12/31</title>
      <link>http://localhost:1313/series/coding-interview/review-1231/</link>
      <pubDate>Wed, 31 Dec 2025 14:57:30 -0500</pubDate>
      
      <guid>http://localhost:1313/series/coding-interview/review-1231/</guid>
      <description> LeeCode ID: #643 Maximum Average Subarray 1 (Programming language: C++) The “Off-By-One” Blid Spot out-of-bound가 발생할 수 있는 코드를 작성했음. index를 iterate할 때, 잘 따져봐야 함. </description>
      
    </item>
    
    <item>
      <title>Sliding Window</title>
      <link>http://localhost:1313/series/coding-pattern/sliding-window/</link>
      <pubDate>Wed, 31 Dec 2025 14:31:49 -0500</pubDate>
      
      <guid>http://localhost:1313/series/coding-pattern/sliding-window/</guid>
      <description> Sliding Window는 array나 string에서 특정 조건을 만족하는 연속된 elements를 찾기 위해서 사용하는 패턴으로써, 핵심은 중복된 연산을 제거하는 것이다. Brute Force: 구간을 이동할 때마다 구간 내의 모든 값을 다시 계산한다. Sliding Window: 윈도우가 한 칸 이동할 때마다 새로 들어오는 값은 더하고, 뒤로 빠지는 값은 빼는 방식으로 연산량을 줄인다. 해당 패턴을 떠올려야 하는 키워드: 연속된(Continuous / Contiguous) 데이터 Subarray, Substring 최대 합, 최소 길이, 모든 아나그램 찾기 LeetCode ID:643. Maximum Average Subarray 1 i = k에서 시작하는 이유를 고민하기 i - k는 out-of-bound를 예방하기 위함 max_sum을 사용하면 왜 효과적인가? #include <vector> #include <algorithm> #include <iostream> class Solution { public: double findMaxAverage(std::vector<int>& nums, int k) { // Use double to prevent precision loss during large additions double current_sum = 0; // Phase 1: Sum the first window (indices 0 to k-1) for (int i = 0; i < k; i++) { current_sum += nums[i]; } // Initialize max_sum with the sum of the very first window double max_sum = current_sum; // Phase 2: Slide the window (start lead pointer at index k) // nums[i] is the element entering, nums[i - k] is the element leaving for (int i = k; i < nums.size(); i++) { current_sum += nums[i] - nums[i - k]; max_sum = std::max(max_sum, current_sum) ; } // Final Step: Perform division only once for maximum accuracy return max_sum / k; } }; </description>
      
    </item>
    
    <item>
      <title>Map</title>
      <link>http://localhost:1313/series/c&#43;&#43;/map/</link>
      <pubDate>Wed, 31 Dec 2025 10:15:03 -0500</pubDate>
      
      <guid>http://localhost:1313/series/c&#43;&#43;/map/</guid>
      <description>C++로 LeetCode에서 HashMap을 사용하려면 **std::unordered_map**을 사용해야 합니다.
C++ 문법이 낯설더라도 알고리즘 문제 풀이에 필요한 핵심 패턴은 정해져 있습니다. 가장 자주 쓰이는 문법과 대표적인 예제인 Two Sum 문제를 통해 설명해 드리겠습니다.
1. C++ HashMap 핵심 문법 (std::unordered_map) # C++에서는 map이 아닌 unordered_map이 해시맵(Hash Table)입니다. (map은 정렬된 트리 구조라 속도가 다릅니다.)
1) 선언 및 라이브러리 추가 # #include <unordered_map> // 필수 헤더 #include <iostream> using namespace std; // std:: 생략 가능 // 선언: unordered_map<Key타입, Value타입> 변수명; unordered_map<string, int> myMap; 2) 데이터 추가 (Insert) # myMap["apple"] = 10; // 가장 직관적인 방법 (추천) myMap.insert({"banana", 20}); 3) 데이터 검색 (Find) - 가장 중요! # LeetCode에서 “이 키가 존재하는가?“를 확인할 때 find() 메서드를 사용합니다.
</description>
      
    </item>
    
    <item>
      <title>Classic Patterns</title>
      <link>http://localhost:1313/series/coding-interview/classic-patterns/</link>
      <pubDate>Thu, 25 Dec 2025 12:36:56 -0500</pubDate>
      
      <guid>http://localhost:1313/series/coding-interview/classic-patterns/</guid>
      <description>1. Array/String # $O(N^2) \rightarrow O(N)$를 요구하는 문제에서 자주 등장함.
Two Pointer: 두 개의 포인터를 양 끝이나 특정 위치에서 시작하여 서로 조작하며 조건을 만족하는 값을 찾는다. 사용 시기: 정렬된 배열에서 쌍(pari) 찾기, 문자열 뒤집기, Palindrome 확인 Sliding Window: 고정되거나 가변적인 크기의 창(windows)을 데이터 위에서 이동시키며 부분 배열/문자열의 특성을 계산한다. (3Sum, Container w/ most water, Trapping rain water) 사용 시기: 연속된 부분 배열(subarray)의 최대/최소 합, 가장 긴 부분 문자열(substring) 문제 (Longest substring w/o repeating characters, Minimun window substring) 2. Graphs & Search # BFS: Queue를 사용하여 가까운 노드부터 탐색한다. 사용 시기: 가중치가 없는 그래프에서 최단 거리(shortest path), 레벨(level) 단위 탐색 (Word ladder, Rotting oranges) DFS: Stack이나 재귀를 사용하여 갈 수 있는 만큼 깊게 탐색한다. 사용 시기: 미로 찾기, 연결된 구성요소(Connected Components) 찾기, 사이클 탐지 (Number of islands, Max area of island) Backtracking: DFS의 일종으로, 가능한 모든 경우의 수를 탐색하되 조건에 맞지 않으면 되돌아가서(pruning) 다시 탐색한다. 사용 시기: 순열(permutation), 조합(combination), 부분 집합(subsets), 스도쿠/N-Queen 문제. (Generate parentheses, Subsets) Topological Sort: 방향성 있는 비순호나 그래프(DAG)에서 순서를 거스르지 않고 나열하는 알고리즘. (주로 Indegree방식 사용) 사용 시기: 선수과목(prerequisite), 빌드 순서(build order), 의존성 해결 문제 (Courser schedule, Alien dictionary) Union-Find / Disjoint Set): 여러 노드가 서로 같은 집합에 속해 있는지 빠르게 확인하고 합치는 알고리즘. 사용 시기: 그래프의 연결성 확인, 무방향 그래프 사이클 탐지, 네트워크 연결 (Number of connected components, Redundant connection) </description>
      
    </item>
    
    <item>
      <title>Review 12/25</title>
      <link>http://localhost:1313/series/coding-interview/review-1225/</link>
      <pubDate>Thu, 25 Dec 2025 11:40:30 -0500</pubDate>
      
      <guid>http://localhost:1313/series/coding-interview/review-1225/</guid>
      <description>Find 3 easy problems involving arrays.
Do not write code immediately. Identify the Pattern (Two pointer? Hash Map?). Create a Trace Table for an edge case on paper. Write the solution trying to use the fewest lines possible. LeeCode ID: #283 Move Zeroes (Programming language: C) 아직 two pointers 방식을 편하게 사용하는 것이 서툰 것 같다. (Classic pattern에 대한 연습 필요: Sliding Window, Slow/Fast Pointer, Two-Pointer)
프로그래밍의 logic은 맞지만, 복잡(multiple if statements)하다. Google Standard: Engineers look for standard patterns. This problem is a classic “Slow & Fast Pointer” pattern (or Partition pattern). Golden Logic: “Iterate through the array. If I see a non-zero, move it to the ‘slow’ pointer position and advance the ‘slow’ pointer. TODO Stop tring to solve every movement logically. Start categorizing problems. Is this a Sliding Window? Is this a Slow/Fast Pointer? Is this a Two-Pointer from ends? Why? Using a standard pattern reduces liens of code by 50% and eliminates bugs like the “consecutive zero” error you had. 손으로 테스트케이스를 돌려보는 작업을 해야 한다.
</description>
      
    </item>
    
    <item>
      <title>Smart Pointer</title>
      <link>http://localhost:1313/series/c&#43;&#43;/smart-pointer/</link>
      <pubDate>Tue, 23 Dec 2025 17:09:46 -0500</pubDate>
      
      <guid>http://localhost:1313/series/c&#43;&#43;/smart-pointer/</guid>
      <description>C++에서는 기본적으로 new로 객체를 생성하고 delete로 해제해야 한다. 하지만, 이 작업을 사람이 직접 관리하다 보면 메모리 누수(memory leak), 이중 해제(double free), dangling pointer같은 문제가 발생하게 된다.
그래서 C++에서는 스마트 포인터(smart pointer)를 사용함으로써 메모리를 안전하게 자동 관리하도록 한다.
객체의 소유권을 명확히 하고, 소유권이 끝나면 자동으로 메모리를 정리한다. Smart pointer
Smart pointer는 객체가 범위(scope)를 벗어날 때 destructor가 자동으로 메모리를 해제한다. C에서는 할당된 메모리에 대해서 개발자가 free()를 해줘야 하는 반면에, C++에서는 compiler가 삽입한 destructor가 자동으로 해제한다. Move Constructor
</description>
      
    </item>
    
    <item>
      <title>Review 12/23</title>
      <link>http://localhost:1313/series/coding-interview/review-1223/</link>
      <pubDate>Tue, 23 Dec 2025 16:11:36 -0500</pubDate>
      
      <guid>http://localhost:1313/series/coding-interview/review-1223/</guid>
      <description> LeeCode ID: #345 Reverse Vowels of a String (Programming language: C)
String을 C로 처리하는데 시간이 많이 걸렸다. C의 string 관련 함수는 모두 null character(’\0’)를 포함하지 않기 때문에 개발자가 직접 넣어줘야 함 (strncpy) Edge case를 code로 표현하는데 서툴렀다. pointer offset을 debugging 하느라 hieh-level logic에 대한 생각을 많이 하지 못했다. 주어진 test case에 대해서 올바르게 동작하는지 확인을 잘 못했다. Interviewer가 제공해준 hint를 catch하고 코드로 작업하는 과정을 잘하지 못했고, 나의 fixing 과정을 설명하지 않았다. (큰 문제임) LeetCode ID: #334 Increasing Triplet Subsequence (Programming language: C)
</description>
      
    </item>
    
    <item>
      <title>345</title>
      <link>http://localhost:1313/series/leetcode75/345/</link>
      <pubDate>Tue, 23 Dec 2025 15:51:36 -0500</pubDate>
      
      <guid>http://localhost:1313/series/leetcode75/345/</guid>
      <description> LeeCode ID: #345 Reverse Vowels of a String </description>
      
    </item>
    
  </channel>
</rss>
